=== tests/cases/conformance/types/typeRelationships/typeInference/unionAndIntersectionInference1.ts ===
// Repro from #2264

interface Y { 'i am a very certain type': Y }
>'i am a very certain type' : Y

var y: Y = <Y>undefined;
>y : Y
><Y>undefined : Y
>undefined : undefined

function destructure<a, r>(
>destructure : <a, r>(something: Y | a, haveValue: (value: a) => r, haveY: (value: Y) => r) => r

    something: a | Y,
>something : Y | a

    haveValue: (value: a) => r,
>haveValue : (value: a) => r
>value : a

    haveY: (value: Y) => r
>haveY : (value: Y) => r
>value : Y

): r {
    return something === y ? haveY(y) : haveValue(<a>something);
>something === y ? haveY(y) : haveValue(<a>something) : r
>something === y : boolean
>something : Y | a
>y : Y
>haveY(y) : r
>haveY : (value: Y) => r
>y : Y
>haveValue(<a>something) : r
>haveValue : (value: a) => r
><a>something : a
>something : Y | a
}

var value = Math.random() > 0.5 ? 'hey!' : <Y>undefined;
>value : string | Y
>Math.random() > 0.5 ? 'hey!' : <Y>undefined : Y | "hey!"
>Math.random() > 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5
>'hey!' : "hey!"
><Y>undefined : Y
>undefined : undefined

var result = destructure(value, text => 'string', y => 'other one'); // text: string, y: Y
>result : string
>destructure(value, text => 'string', y => 'other one') : string
>destructure : <a, r>(something: Y | a, haveValue: (value: a) => r, haveY: (value: Y) => r) => r
>value : string | Y
>text => 'string' : (text: string) => string
>text : string
>'string' : "string"
>y => 'other one' : (y: Y) => string
>y : Y
>'other one' : "other one"

// Repro from #4212

function isVoid<a>(value: void | a): value is void {
>isVoid : <a>(value: void | a) => value is void
>value : void | a

    return undefined;
>undefined : undefined
}

function isNonVoid<a>(value: void | a) : value is a {
>isNonVoid : <a>(value: void | a) => value is a
>value : void | a

    return undefined;
>undefined : undefined
}

function foo1<a>(value: void|a): void {
>foo1 : <a>(value: void | a) => void
>value : void | a

    if (isVoid(value)) {
>isVoid(value) : boolean
>isVoid : <a>(value: void | a) => value is void
>value : void | a

        value; // value is void
>value : void

    } else {
        value; // value is a
>value : a
    }
}

function baz1<a>(value: void|a): void {
>baz1 : <a>(value: void | a) => void
>value : void | a

      if (isNonVoid(value)) {
>isNonVoid(value) : boolean
>isNonVoid : <a>(value: void | a) => value is a
>value : void | a

          value; // value is a
>value : a

      } else {
          value; // value is void
>value : void
      }
}

// Repro from #5417

type Maybe<T> = T | void;
>Maybe : Maybe<T>

function get<U>(x: U | void): U {
>get : <U>(x: void | U) => U
>x : void | U

   return null; // just an example
>null : null
}

let foo: Maybe<string>;
>foo : Maybe<string>

get(foo).toUpperCase(); // Ok
>get(foo).toUpperCase() : string
>get(foo).toUpperCase : () => string
>get(foo) : string
>get : <U>(x: void | U) => U
>foo : Maybe<string>
>toUpperCase : () => string

// Repro from #5456

interface Man {
    walks: boolean;
>walks : boolean
}

interface Bear {
    roars: boolean;
>roars : boolean
}

interface Pig {
    oinks: boolean;
>oinks : boolean
}

declare function pigify<T>(y: T & Bear): T & Pig;
>pigify : <T>(y: T & Bear) => T & Pig
>y : T & Bear

declare var mbp: Man & Bear;
>mbp : Man & Bear

pigify(mbp).oinks; // OK, mbp is treated as Pig
>pigify(mbp).oinks : boolean
>pigify(mbp) : Man & Pig
>pigify : <T>(y: T & Bear) => T & Pig
>mbp : Man & Bear
>oinks : boolean

pigify(mbp).walks; // Ok, mbp is treated as Man
>pigify(mbp).walks : boolean
>pigify(mbp) : Man & Pig
>pigify : <T>(y: T & Bear) => T & Pig
>mbp : Man & Bear
>walks : boolean

