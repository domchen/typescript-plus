=== tests/cases/conformance/parser/ecmascript5/parserRealSource12.ts ===
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='typescript.ts' />

module TypeScript {
>TypeScript : typeof TypeScript

    export interface IAstWalker {
        walk(ast: AST, parent: AST): AST;
>walk : (ast: any, parent: any) => any
>ast : any
>parent : any

        options: AstWalkOptions;
>options : AstWalkOptions

        state: any; // user state object
>state : any
    }

    export class AstWalkOptions {
>AstWalkOptions : AstWalkOptions

        public goChildren = true;
>goChildren : boolean
>true : true

        public goNextSibling = true;
>goNextSibling : boolean
>true : true

        public reverseSiblings = false; // visit siblings in reverse execution order
>reverseSiblings : boolean
>false : false

        public stopWalk(stop:boolean = true) {
>stopWalk : (stop?: boolean) => void
>stop : boolean
>true : true

            this.goChildren = !stop;
>this.goChildren = !stop : boolean
>this.goChildren : boolean
>this : this
>goChildren : boolean
>!stop : boolean
>stop : boolean

            this.goNextSibling = !stop;
>this.goNextSibling = !stop : boolean
>this.goNextSibling : boolean
>this : this
>goNextSibling : boolean
>!stop : boolean
>stop : boolean
        }
    }

    export interface IAstWalkCallback {
        (ast: AST, parent: AST, walker: IAstWalker): AST;
>ast : any
>parent : any
>walker : IAstWalker
    }

    export interface IAstWalkChildren {
        (preAst: AST, parent: AST, walker: IAstWalker): void;
>preAst : any
>parent : any
>walker : IAstWalker
    }

    class AstWalker implements IAstWalker {
>AstWalker : AstWalker

        constructor (
            private childrenWalkers: IAstWalkChildren[],
>childrenWalkers : IAstWalkChildren[]

            private pre: IAstWalkCallback,
>pre : IAstWalkCallback

            private post: IAstWalkCallback,
>post : IAstWalkCallback

            public options: AstWalkOptions,
>options : AstWalkOptions

            public state: any) {
>state : any
        }

        public walk(ast: AST, parent: AST): AST {
>walk : (ast: any, parent: any) => any
>ast : any
>parent : any

            var preAst = this.pre(ast, parent, this);
>preAst : any
>this.pre(ast, parent, this) : any
>this.pre : IAstWalkCallback
>this : this
>pre : IAstWalkCallback
>ast : any
>parent : any
>this : this

            if (preAst === undefined) {
>preAst === undefined : boolean
>preAst : any
>undefined : undefined

                preAst = ast;
>preAst = ast : any
>preAst : any
>ast : any
            }
            if (this.options.goChildren) {
>this.options.goChildren : boolean
>this.options : AstWalkOptions
>this : this
>options : AstWalkOptions
>goChildren : boolean

                var svGoSib = this.options.goNextSibling;
>svGoSib : boolean
>this.options.goNextSibling : boolean
>this.options : AstWalkOptions
>this : this
>options : AstWalkOptions
>goNextSibling : boolean

                this.options.goNextSibling = true;
>this.options.goNextSibling = true : true
>this.options.goNextSibling : boolean
>this.options : AstWalkOptions
>this : this
>options : AstWalkOptions
>goNextSibling : boolean
>true : true

                // Call the "walkChildren" function corresponding to "nodeType".
                this.childrenWalkers[ast.nodeType](ast, parent, this);
>this.childrenWalkers[ast.nodeType](ast, parent, this) : void
>this.childrenWalkers[ast.nodeType] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>ast.nodeType : any
>ast : any
>nodeType : any
>ast : any
>parent : any
>this : this

                this.options.goNextSibling = svGoSib;
>this.options.goNextSibling = svGoSib : boolean
>this.options.goNextSibling : boolean
>this.options : AstWalkOptions
>this : this
>options : AstWalkOptions
>goNextSibling : boolean
>svGoSib : boolean
            }
            else {
                // no go only applies to children of node issuing it
                this.options.goChildren = true;
>this.options.goChildren = true : true
>this.options.goChildren : boolean
>this.options : AstWalkOptions
>this : this
>options : AstWalkOptions
>goChildren : boolean
>true : true
            }
            if (this.post) {
>this.post : IAstWalkCallback
>this : this
>post : IAstWalkCallback

                var postAst = this.post(preAst, parent, this);
>postAst : any
>this.post(preAst, parent, this) : any
>this.post : IAstWalkCallback
>this : this
>post : IAstWalkCallback
>preAst : any
>parent : any
>this : this

                if (postAst === undefined) {
>postAst === undefined : boolean
>postAst : any
>undefined : undefined

                    postAst = preAst;
>postAst = preAst : any
>postAst : any
>preAst : any
                }
                return postAst;
>postAst : any
            }
            else {
                return preAst;
>preAst : any
            }
        }
    }

    export class AstWalkerFactory {
>AstWalkerFactory : AstWalkerFactory

        private childrenWalkers: IAstWalkChildren[] = [];
>childrenWalkers : IAstWalkChildren[]
>[] : undefined[]

        constructor () {
            this.initChildrenWalkers();
>this.initChildrenWalkers() : void
>this.initChildrenWalkers : () => void
>this : this
>initChildrenWalkers : () => void
        }

        public walk(ast: AST, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): AST {
>walk : (ast: any, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any) => any
>ast : any
>pre : IAstWalkCallback
>post : IAstWalkCallback
>options : AstWalkOptions
>state : any

            return this.getWalker(pre, post, options, state).walk(ast, null)
>this.getWalker(pre, post, options, state).walk(ast, null) : any
>this.getWalker(pre, post, options, state).walk : (ast: any, parent: any) => any
>this.getWalker(pre, post, options, state) : IAstWalker
>this.getWalker : (pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any) => IAstWalker
>this : this
>getWalker : (pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any) => IAstWalker
>pre : IAstWalkCallback
>post : IAstWalkCallback
>options : AstWalkOptions
>state : any
>walk : (ast: any, parent: any) => any
>ast : any
>null : null
        }

        public getWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {
>getWalker : (pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any) => IAstWalker
>pre : IAstWalkCallback
>post : IAstWalkCallback
>options : AstWalkOptions
>state : any

            return this.getSlowWalker(pre, post, options, state);
>this.getSlowWalker(pre, post, options, state) : IAstWalker
>this.getSlowWalker : (pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any) => IAstWalker
>this : this
>getSlowWalker : (pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any) => IAstWalker
>pre : IAstWalkCallback
>post : IAstWalkCallback
>options : AstWalkOptions
>state : any
        }

        private getSlowWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {
>getSlowWalker : (pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any) => IAstWalker
>pre : IAstWalkCallback
>post : IAstWalkCallback
>options : AstWalkOptions
>state : any

            if (!options) {
>!options : boolean
>options : AstWalkOptions

                options = new AstWalkOptions();
>options = new AstWalkOptions() : AstWalkOptions
>options : AstWalkOptions
>new AstWalkOptions() : AstWalkOptions
>AstWalkOptions : typeof AstWalkOptions
            }

            return new AstWalker(this.childrenWalkers, pre, post, options, state);
>new AstWalker(this.childrenWalkers, pre, post, options, state) : AstWalker
>AstWalker : typeof AstWalker
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>pre : IAstWalkCallback
>post : IAstWalkCallback
>options : AstWalkOptions
>state : any
        }

        private initChildrenWalkers(): void {
>initChildrenWalkers : () => void

            this.childrenWalkers[NodeType.None] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.None] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.None] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.None : any
>NodeType : any
>None : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Empty] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Empty] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Empty] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Empty : any
>NodeType : any
>Empty : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.EmptyExpr] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.EmptyExpr] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.EmptyExpr] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.EmptyExpr : any
>NodeType : any
>EmptyExpr : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.True] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.True] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.True] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.True : any
>NodeType : any
>True : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.False] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.False] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.False] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.False : any
>NodeType : any
>False : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.This] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.This] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.This] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.This : any
>NodeType : any
>This : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Super] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Super] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Super] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Super : any
>NodeType : any
>Super : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.QString] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.QString] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.QString] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.QString : any
>NodeType : any
>QString : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Regex] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Regex] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Regex] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Regex : any
>NodeType : any
>Regex : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Null] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Null] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Null] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Null : any
>NodeType : any
>Null : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.ArrayLit] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.ArrayLit : any
>NodeType : any
>ArrayLit : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.ObjectLit] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.ObjectLit : any
>NodeType : any
>ObjectLit : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Void] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.Void] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Void] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Void : any
>NodeType : any
>Void : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Comma] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Comma : any
>NodeType : any
>Comma : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Pos] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Pos : any
>NodeType : any
>Pos : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Neg] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Neg : any
>NodeType : any
>Neg : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Delete] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Delete : any
>NodeType : any
>Delete : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Await] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Await : any
>NodeType : any
>Await : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.In] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.In : any
>NodeType : any
>In : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Dot] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Dot : any
>NodeType : any
>Dot : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.From] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.From : any
>NodeType : any
>From : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Is] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Is : any
>NodeType : any
>Is : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.InstOf] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.InstOf : any
>NodeType : any
>InstOf : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Typeof] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Typeof : any
>NodeType : any
>Typeof : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.NumberLit] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.NumberLit] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.NumberLit] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.NumberLit : any
>NodeType : any
>NumberLit : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Name] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Name] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Name] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Name : any
>NodeType : any
>Name : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;
>this.childrenWalkers[NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.TypeRef] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.TypeRef : any
>NodeType : any
>TypeRef : any
>ChildrenWalkers.walkTypeReferenceChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkTypeReferenceChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Index] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Index : any
>NodeType : any
>Index : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren;
>this.childrenWalkers[NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Call] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Call : any
>NodeType : any
>Call : any
>ChildrenWalkers.walkCallExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkCallExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.New] = ChildrenWalkers.walkCallExpressionChildren;
>this.childrenWalkers[NodeType.New] = ChildrenWalkers.walkCallExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.New] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.New : any
>NodeType : any
>New : any
>ChildrenWalkers.walkCallExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkCallExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Asg] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Asg : any
>NodeType : any
>Asg : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgAdd] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgAdd : any
>NodeType : any
>AsgAdd : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgSub] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgSub : any
>NodeType : any
>AsgSub : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgDiv] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgDiv : any
>NodeType : any
>AsgDiv : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgMul] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgMul : any
>NodeType : any
>AsgMul : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgMod] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgMod : any
>NodeType : any
>AsgMod : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgAnd] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgAnd : any
>NodeType : any
>AsgAnd : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgXor] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgXor : any
>NodeType : any
>AsgXor : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgOr] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgOr : any
>NodeType : any
>AsgOr : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgLsh] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgLsh : any
>NodeType : any
>AsgLsh : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgRsh] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgRsh : any
>NodeType : any
>AsgRsh : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.AsgRs2] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.AsgRs2 : any
>NodeType : any
>AsgRs2 : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren;
>this.childrenWalkers[NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.ConditionalExpression] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.ConditionalExpression : any
>NodeType : any
>ConditionalExpression : any
>ChildrenWalkers.walkTrinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkTrinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.LogOr] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.LogOr : any
>NodeType : any
>LogOr : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.LogAnd] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.LogAnd : any
>NodeType : any
>LogAnd : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Or] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Or : any
>NodeType : any
>Or : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Xor] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Xor : any
>NodeType : any
>Xor : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.And] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.And : any
>NodeType : any
>And : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Eq] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Eq : any
>NodeType : any
>Eq : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Ne] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Ne : any
>NodeType : any
>Ne : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Eqv] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Eqv : any
>NodeType : any
>Eqv : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.NEqv] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.NEqv : any
>NodeType : any
>NEqv : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Lt] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Lt : any
>NodeType : any
>Lt : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Le] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Le : any
>NodeType : any
>Le : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Gt] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Gt : any
>NodeType : any
>Gt : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Ge] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Ge : any
>NodeType : any
>Ge : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Add] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Add : any
>NodeType : any
>Add : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Sub] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Sub : any
>NodeType : any
>Sub : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Mul] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Mul : any
>NodeType : any
>Mul : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Div] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Div : any
>NodeType : any
>Div : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Mod] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Mod : any
>NodeType : any
>Mod : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Lsh] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Lsh : any
>NodeType : any
>Lsh : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Rsh] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Rsh : any
>NodeType : any
>Rsh : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Rs2] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Rs2 : any
>NodeType : any
>Rs2 : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Not] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Not : any
>NodeType : any
>Not : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.LogNot] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.LogNot : any
>NodeType : any
>LogNot : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.IncPre] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.IncPre : any
>NodeType : any
>IncPre : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.DecPre] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.DecPre : any
>NodeType : any
>DecPre : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.IncPost] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.IncPost : any
>NodeType : any
>IncPost : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.DecPost] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.DecPost : any
>NodeType : any
>DecPost : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.TypeAssertion] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.TypeAssertion : any
>NodeType : any
>TypeAssertion : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren;
>this.childrenWalkers[NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.FuncDecl] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.FuncDecl : any
>NodeType : any
>FuncDecl : any
>ChildrenWalkers.walkFuncDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkFuncDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;
>this.childrenWalkers[NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Member] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Member : any
>NodeType : any
>Member : any
>ChildrenWalkers.walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren;
>this.childrenWalkers[NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.VarDecl] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.VarDecl : any
>NodeType : any
>VarDecl : any
>ChildrenWalkers.walkBoundDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBoundDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren;
>this.childrenWalkers[NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.ArgDecl] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.ArgDecl : any
>NodeType : any
>ArgDecl : any
>ChildrenWalkers.walkBoundDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBoundDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren;
>this.childrenWalkers[NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Return] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Return : any
>NodeType : any
>Return : any
>ChildrenWalkers.walkReturnStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkReturnStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Break] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Break] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Break] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Break : any
>NodeType : any
>Break : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Continue] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Continue] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Continue] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Continue : any
>NodeType : any
>Continue : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren;
>this.childrenWalkers[NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Throw] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Throw : any
>NodeType : any
>Throw : any
>ChildrenWalkers.walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.For] = ChildrenWalkers.walkForStatementChildren;
>this.childrenWalkers[NodeType.For] = ChildrenWalkers.walkForStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.For] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.For : any
>NodeType : any
>For : any
>ChildrenWalkers.walkForStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkForStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren;
>this.childrenWalkers[NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.ForIn] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.ForIn : any
>NodeType : any
>ForIn : any
>ChildrenWalkers.walkForInStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkForInStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.If] = ChildrenWalkers.walkIfStatementChildren;
>this.childrenWalkers[NodeType.If] = ChildrenWalkers.walkIfStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.If] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.If : any
>NodeType : any
>If : any
>ChildrenWalkers.walkIfStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkIfStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.While] = ChildrenWalkers.walkWhileStatementChildren;
>this.childrenWalkers[NodeType.While] = ChildrenWalkers.walkWhileStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.While] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.While : any
>NodeType : any
>While : any
>ChildrenWalkers.walkWhileStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkWhileStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren;
>this.childrenWalkers[NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.DoWhile] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.DoWhile : any
>NodeType : any
>DoWhile : any
>ChildrenWalkers.walkDoWhileStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkDoWhileStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Block] = ChildrenWalkers.walkBlockChildren;
>this.childrenWalkers[NodeType.Block] = ChildrenWalkers.walkBlockChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Block] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Block : any
>NodeType : any
>Block : any
>ChildrenWalkers.walkBlockChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkBlockChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren;
>this.childrenWalkers[NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Case] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Case : any
>NodeType : any
>Case : any
>ChildrenWalkers.walkCaseStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkCaseStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren;
>this.childrenWalkers[NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Switch] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Switch : any
>NodeType : any
>Switch : any
>ChildrenWalkers.walkSwitchStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkSwitchStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Try] = ChildrenWalkers.walkTryChildren;
>this.childrenWalkers[NodeType.Try] = ChildrenWalkers.walkTryChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Try] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Try : any
>NodeType : any
>Try : any
>ChildrenWalkers.walkTryChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkTryChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren;
>this.childrenWalkers[NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.TryCatch] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.TryCatch : any
>NodeType : any
>TryCatch : any
>ChildrenWalkers.walkTryCatchChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkTryCatchChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren;
>this.childrenWalkers[NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.TryFinally] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.TryFinally : any
>NodeType : any
>TryFinally : any
>ChildrenWalkers.walkTryFinallyChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkTryFinallyChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Finally] = ChildrenWalkers.walkFinallyChildren;
>this.childrenWalkers[NodeType.Finally] = ChildrenWalkers.walkFinallyChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Finally] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Finally : any
>NodeType : any
>Finally : any
>ChildrenWalkers.walkFinallyChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkFinallyChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Catch] = ChildrenWalkers.walkCatchChildren;
>this.childrenWalkers[NodeType.Catch] = ChildrenWalkers.walkCatchChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Catch] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Catch : any
>NodeType : any
>Catch : any
>ChildrenWalkers.walkCatchChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkCatchChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.List] = ChildrenWalkers.walkListChildren;
>this.childrenWalkers[NodeType.List] = ChildrenWalkers.walkListChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.List] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.List : any
>NodeType : any
>List : any
>ChildrenWalkers.walkListChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkListChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Script] = ChildrenWalkers.walkScriptChildren;
>this.childrenWalkers[NodeType.Script] = ChildrenWalkers.walkScriptChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Script] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Script : any
>NodeType : any
>Script : any
>ChildrenWalkers.walkScriptChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkScriptChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren;
>this.childrenWalkers[NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.ClassDeclaration] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.ClassDeclaration : any
>NodeType : any
>ClassDeclaration : any
>ChildrenWalkers.walkClassDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkClassDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren;
>this.childrenWalkers[NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.InterfaceDeclaration] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.InterfaceDeclaration : any
>NodeType : any
>InterfaceDeclaration : any
>ChildrenWalkers.walkTypeDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkTypeDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren;
>this.childrenWalkers[NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.ModuleDeclaration] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.ModuleDeclaration : any
>NodeType : any
>ModuleDeclaration : any
>ChildrenWalkers.walkModuleDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkModuleDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren;
>this.childrenWalkers[NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.ImportDeclaration] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.ImportDeclaration : any
>NodeType : any
>ImportDeclaration : any
>ChildrenWalkers.walkImportDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkImportDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.With] = ChildrenWalkers.walkWithStatementChildren;
>this.childrenWalkers[NodeType.With] = ChildrenWalkers.walkWithStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.With] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.With : any
>NodeType : any
>With : any
>ChildrenWalkers.walkWithStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkWithStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Label] = ChildrenWalkers.walkLabelChildren;
>this.childrenWalkers[NodeType.Label] = ChildrenWalkers.walkLabelChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Label] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Label : any
>NodeType : any
>Label : any
>ChildrenWalkers.walkLabelChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkLabelChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;
>this.childrenWalkers[NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.LabeledStatement] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.LabeledStatement : any
>NodeType : any
>LabeledStatement : any
>ChildrenWalkers.walkLabeledStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkLabeledStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.EBStart] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.EBStart] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.EBStart] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.EBStart : any
>NodeType : any
>EBStart : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.GotoEB] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.GotoEB] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.GotoEB] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.GotoEB : any
>NodeType : any
>GotoEB : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.EndCode] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.EndCode] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.EndCode] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.EndCode : any
>NodeType : any
>EndCode : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Error] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Error] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Error] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Error : any
>NodeType : any
>Error : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Comment] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Comment] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Comment] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Comment : any
>NodeType : any
>Comment : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            this.childrenWalkers[NodeType.Debugger] = ChildrenWalkers.walkNone;
>this.childrenWalkers[NodeType.Debugger] = ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>this.childrenWalkers[NodeType.Debugger] : IAstWalkChildren
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>NodeType.Debugger : any
>NodeType : any
>Debugger : any
>ChildrenWalkers.walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>ChildrenWalkers : typeof ChildrenWalkers
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void

            // Verify the code is up to date with the enum
            for (var e in (<any>NodeType)._map) {
>e : string
>(<any>NodeType)._map : any
>(<any>NodeType) : any
><any>NodeType : any
>NodeType : any
>_map : any

                if ((<any>this.childrenWalkers)[e] === undefined) {
>(<any>this.childrenWalkers)[e] === undefined : boolean
>(<any>this.childrenWalkers)[e] : any
>(<any>this.childrenWalkers) : any
><any>this.childrenWalkers : any
>this.childrenWalkers : IAstWalkChildren[]
>this : this
>childrenWalkers : IAstWalkChildren[]
>e : string
>undefined : undefined

                    throw new Error("initWalkers function is not up to date with enum content!");
>new Error("initWalkers function is not up to date with enum content!") : Error
>Error : ErrorConstructor
>"initWalkers function is not up to date with enum content!" : "initWalkers function is not up to date with enum content!"
                }
            }
        }
    }

    var globalAstWalkerFactory: AstWalkerFactory;
>globalAstWalkerFactory : AstWalkerFactory

    export function getAstWalkerFactory(): AstWalkerFactory {
>getAstWalkerFactory : () => AstWalkerFactory

        if (!globalAstWalkerFactory) {
>!globalAstWalkerFactory : boolean
>globalAstWalkerFactory : AstWalkerFactory

            globalAstWalkerFactory = new AstWalkerFactory();
>globalAstWalkerFactory = new AstWalkerFactory() : AstWalkerFactory
>globalAstWalkerFactory : AstWalkerFactory
>new AstWalkerFactory() : AstWalkerFactory
>AstWalkerFactory : typeof AstWalkerFactory
        }
        return globalAstWalkerFactory;
>globalAstWalkerFactory : AstWalkerFactory
    }

    module ChildrenWalkers {
>ChildrenWalkers : typeof ChildrenWalkers

        export function walkNone(preAst: ASTList, parent: AST, walker: IAstWalker): void {
>walkNone : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            // Nothing to do
        }

        export function walkListChildren(preAst: ASTList, parent: AST, walker: IAstWalker): void {
>walkListChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            var len = preAst.members.length;
>len : any
>preAst.members.length : any
>preAst.members : any
>preAst : any
>members : any
>length : any

            if (walker.options.reverseSiblings) {
>walker.options.reverseSiblings : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>reverseSiblings : boolean

                for (var i = len - 1; i >= 0; i--) {
>i : number
>len - 1 : number
>len : any
>1 : 1
>i >= 0 : boolean
>i : number
>0 : 0
>i-- : number
>i : number

                    if (walker.options.goNextSibling) {
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                        preAst.members[i] = walker.walk(preAst.members[i], preAst);
>preAst.members[i] = walker.walk(preAst.members[i], preAst) : any
>preAst.members[i] : any
>preAst.members : any
>preAst : any
>members : any
>i : number
>walker.walk(preAst.members[i], preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.members[i] : any
>preAst.members : any
>preAst : any
>members : any
>i : number
>preAst : any
                    }
                }
            }
            else {
                for (var i = 0; i < len; i++) {
>i : number
>0 : 0
>i < len : boolean
>i : number
>len : any
>i++ : number
>i : number

                    if (walker.options.goNextSibling) {
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                        preAst.members[i] = walker.walk(preAst.members[i], preAst);
>preAst.members[i] = walker.walk(preAst.members[i], preAst) : any
>preAst.members[i] : any
>preAst.members : any
>preAst : any
>members : any
>i : number
>walker.walk(preAst.members[i], preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.members[i] : any
>preAst.members : any
>preAst : any
>members : any
>i : number
>preAst : any
                    }
                }
            }
        }

        export function walkUnaryExpressionChildren(preAst: UnaryExpression, parent: AST, walker: IAstWalker): void {
>walkUnaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.castTerm) {
>preAst.castTerm : any
>preAst : any
>castTerm : any

                preAst.castTerm = walker.walk(preAst.castTerm, preAst);
>preAst.castTerm = walker.walk(preAst.castTerm, preAst) : any
>preAst.castTerm : any
>preAst : any
>castTerm : any
>walker.walk(preAst.castTerm, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.castTerm : any
>preAst : any
>castTerm : any
>preAst : any
            }
            if (preAst.operand) {
>preAst.operand : any
>preAst : any
>operand : any

                preAst.operand = walker.walk(preAst.operand, preAst);
>preAst.operand = walker.walk(preAst.operand, preAst) : any
>preAst.operand : any
>preAst : any
>operand : any
>walker.walk(preAst.operand, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.operand : any
>preAst : any
>operand : any
>preAst : any
            }
        }

        export function walkBinaryExpressionChildren(preAst: BinaryExpression, parent: AST, walker: IAstWalker): void {
>walkBinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (walker.options.reverseSiblings) {
>walker.options.reverseSiblings : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>reverseSiblings : boolean

                if (preAst.operand2) {
>preAst.operand2 : any
>preAst : any
>operand2 : any

                    preAst.operand2 = walker.walk(preAst.operand2, preAst);
>preAst.operand2 = walker.walk(preAst.operand2, preAst) : any
>preAst.operand2 : any
>preAst : any
>operand2 : any
>walker.walk(preAst.operand2, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.operand2 : any
>preAst : any
>operand2 : any
>preAst : any
                }
                if ((preAst.operand1) && (walker.options.goNextSibling)) {
>(preAst.operand1) && (walker.options.goNextSibling) : boolean
>(preAst.operand1) : any
>preAst.operand1 : any
>preAst : any
>operand1 : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                    preAst.operand1 = walker.walk(preAst.operand1, preAst);
>preAst.operand1 = walker.walk(preAst.operand1, preAst) : any
>preAst.operand1 : any
>preAst : any
>operand1 : any
>walker.walk(preAst.operand1, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.operand1 : any
>preAst : any
>operand1 : any
>preAst : any
                }
            } else {
                if (preAst.operand1) {
>preAst.operand1 : any
>preAst : any
>operand1 : any

                    preAst.operand1 = walker.walk(preAst.operand1, preAst);
>preAst.operand1 = walker.walk(preAst.operand1, preAst) : any
>preAst.operand1 : any
>preAst : any
>operand1 : any
>walker.walk(preAst.operand1, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.operand1 : any
>preAst : any
>operand1 : any
>preAst : any
                }
                if ((preAst.operand2) && (walker.options.goNextSibling)) {
>(preAst.operand2) && (walker.options.goNextSibling) : boolean
>(preAst.operand2) : any
>preAst.operand2 : any
>preAst : any
>operand2 : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                    preAst.operand2 = walker.walk(preAst.operand2, preAst);
>preAst.operand2 = walker.walk(preAst.operand2, preAst) : any
>preAst.operand2 : any
>preAst : any
>operand2 : any
>walker.walk(preAst.operand2, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.operand2 : any
>preAst : any
>operand2 : any
>preAst : any
                }
            }
        }

        export function walkTypeReferenceChildren(preAst: TypeReference, parent: AST, walker: IAstWalker): void {
>walkTypeReferenceChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.term) {
>preAst.term : any
>preAst : any
>term : any

                preAst.term = walker.walk(preAst.term, preAst);
>preAst.term = walker.walk(preAst.term, preAst) : any
>preAst.term : any
>preAst : any
>term : any
>walker.walk(preAst.term, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.term : any
>preAst : any
>term : any
>preAst : any
            }
        }

        export function walkCallExpressionChildren(preAst: CallExpression, parent: AST, walker: IAstWalker): void {
>walkCallExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (!walker.options.reverseSiblings) {
>!walker.options.reverseSiblings : boolean
>walker.options.reverseSiblings : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>reverseSiblings : boolean

                preAst.target = walker.walk(preAst.target, preAst);
>preAst.target = walker.walk(preAst.target, preAst) : any
>preAst.target : any
>preAst : any
>target : any
>walker.walk(preAst.target, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.target : any
>preAst : any
>target : any
>preAst : any
            }
            if (preAst.arguments && (walker.options.goNextSibling)) {
>preAst.arguments && (walker.options.goNextSibling) : boolean
>preAst.arguments : any
>preAst : any
>arguments : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.arguments = <ASTList> walker.walk(preAst.arguments, preAst);
>preAst.arguments = <ASTList> walker.walk(preAst.arguments, preAst) : any
>preAst.arguments : any
>preAst : any
>arguments : any
><ASTList> walker.walk(preAst.arguments, preAst) : any
>walker.walk(preAst.arguments, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.arguments : any
>preAst : any
>arguments : any
>preAst : any
            }
            if ((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {
>(walker.options.reverseSiblings) && (walker.options.goNextSibling) : boolean
>(walker.options.reverseSiblings) : boolean
>walker.options.reverseSiblings : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>reverseSiblings : boolean
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.target = walker.walk(preAst.target, preAst);
>preAst.target = walker.walk(preAst.target, preAst) : any
>preAst.target : any
>preAst : any
>target : any
>walker.walk(preAst.target, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.target : any
>preAst : any
>target : any
>preAst : any
            }
        }

        export function walkTrinaryExpressionChildren(preAst: ConditionalExpression, parent: AST, walker: IAstWalker): void {
>walkTrinaryExpressionChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.operand1) {
>preAst.operand1 : any
>preAst : any
>operand1 : any

                preAst.operand1 = walker.walk(preAst.operand1, preAst);
>preAst.operand1 = walker.walk(preAst.operand1, preAst) : any
>preAst.operand1 : any
>preAst : any
>operand1 : any
>walker.walk(preAst.operand1, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.operand1 : any
>preAst : any
>operand1 : any
>preAst : any
            }
            if (preAst.operand2 && (walker.options.goNextSibling)) {
>preAst.operand2 && (walker.options.goNextSibling) : boolean
>preAst.operand2 : any
>preAst : any
>operand2 : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.operand2 = walker.walk(preAst.operand2, preAst);
>preAst.operand2 = walker.walk(preAst.operand2, preAst) : any
>preAst.operand2 : any
>preAst : any
>operand2 : any
>walker.walk(preAst.operand2, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.operand2 : any
>preAst : any
>operand2 : any
>preAst : any
            }
            if (preAst.operand3 && (walker.options.goNextSibling)) {
>preAst.operand3 && (walker.options.goNextSibling) : boolean
>preAst.operand3 : any
>preAst : any
>operand3 : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.operand3 = walker.walk(preAst.operand3, preAst);
>preAst.operand3 = walker.walk(preAst.operand3, preAst) : any
>preAst.operand3 : any
>preAst : any
>operand3 : any
>walker.walk(preAst.operand3, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.operand3 : any
>preAst : any
>operand3 : any
>preAst : any
            }
        }

        export function walkFuncDeclChildren(preAst: FuncDecl, parent: AST, walker: IAstWalker): void {
>walkFuncDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.name) {
>preAst.name : any
>preAst : any
>name : any

                preAst.name = <Identifier>walker.walk(preAst.name, preAst);
>preAst.name = <Identifier>walker.walk(preAst.name, preAst) : any
>preAst.name : any
>preAst : any
>name : any
><Identifier>walker.walk(preAst.name, preAst) : any
>walker.walk(preAst.name, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.name : any
>preAst : any
>name : any
>preAst : any
            }
            if (preAst.arguments && (preAst.arguments.members.length > 0) && (walker.options.goNextSibling)) {
>preAst.arguments && (preAst.arguments.members.length > 0) && (walker.options.goNextSibling) : boolean
>preAst.arguments && (preAst.arguments.members.length > 0) : boolean
>preAst.arguments : any
>preAst : any
>arguments : any
>(preAst.arguments.members.length > 0) : boolean
>preAst.arguments.members.length > 0 : boolean
>preAst.arguments.members.length : any
>preAst.arguments.members : any
>preAst.arguments : any
>preAst : any
>arguments : any
>members : any
>length : any
>0 : 0
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.arguments = <ASTList>walker.walk(preAst.arguments, preAst);
>preAst.arguments = <ASTList>walker.walk(preAst.arguments, preAst) : any
>preAst.arguments : any
>preAst : any
>arguments : any
><ASTList>walker.walk(preAst.arguments, preAst) : any
>walker.walk(preAst.arguments, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.arguments : any
>preAst : any
>arguments : any
>preAst : any
            }
            if (preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {
>preAst.returnTypeAnnotation && (walker.options.goNextSibling) : boolean
>preAst.returnTypeAnnotation : any
>preAst : any
>returnTypeAnnotation : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);
>preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst) : any
>preAst.returnTypeAnnotation : any
>preAst : any
>returnTypeAnnotation : any
>walker.walk(preAst.returnTypeAnnotation, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.returnTypeAnnotation : any
>preAst : any
>returnTypeAnnotation : any
>preAst : any
            }
            if (preAst.bod && (preAst.bod.members.length > 0) && (walker.options.goNextSibling)) {
>preAst.bod && (preAst.bod.members.length > 0) && (walker.options.goNextSibling) : boolean
>preAst.bod && (preAst.bod.members.length > 0) : boolean
>preAst.bod : any
>preAst : any
>bod : any
>(preAst.bod.members.length > 0) : boolean
>preAst.bod.members.length > 0 : boolean
>preAst.bod.members.length : any
>preAst.bod.members : any
>preAst.bod : any
>preAst : any
>bod : any
>members : any
>length : any
>0 : 0
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);
>preAst.bod = <ASTList>walker.walk(preAst.bod, preAst) : any
>preAst.bod : any
>preAst : any
>bod : any
><ASTList>walker.walk(preAst.bod, preAst) : any
>walker.walk(preAst.bod, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.bod : any
>preAst : any
>bod : any
>preAst : any
            }
        }

        export function walkBoundDeclChildren(preAst: BoundDecl, parent: AST, walker: IAstWalker): void {
>walkBoundDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.id) {
>preAst.id : any
>preAst : any
>id : any

                preAst.id = <Identifier>walker.walk(preAst.id, preAst);
>preAst.id = <Identifier>walker.walk(preAst.id, preAst) : any
>preAst.id : any
>preAst : any
>id : any
><Identifier>walker.walk(preAst.id, preAst) : any
>walker.walk(preAst.id, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.id : any
>preAst : any
>id : any
>preAst : any
            }
            if (preAst.init) {
>preAst.init : any
>preAst : any
>init : any

                preAst.init = walker.walk(preAst.init, preAst);
>preAst.init = walker.walk(preAst.init, preAst) : any
>preAst.init : any
>preAst : any
>init : any
>walker.walk(preAst.init, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.init : any
>preAst : any
>init : any
>preAst : any
            }
            if ((preAst.typeExpr) && (walker.options.goNextSibling)) {
>(preAst.typeExpr) && (walker.options.goNextSibling) : boolean
>(preAst.typeExpr) : any
>preAst.typeExpr : any
>preAst : any
>typeExpr : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);
>preAst.typeExpr = walker.walk(preAst.typeExpr, preAst) : any
>preAst.typeExpr : any
>preAst : any
>typeExpr : any
>walker.walk(preAst.typeExpr, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.typeExpr : any
>preAst : any
>typeExpr : any
>preAst : any
            }
        }

        export function walkReturnStatementChildren(preAst: ReturnStatement, parent: AST, walker: IAstWalker): void {
>walkReturnStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.returnExpression) {
>preAst.returnExpression : any
>preAst : any
>returnExpression : any

                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);
>preAst.returnExpression = walker.walk(preAst.returnExpression, preAst) : any
>preAst.returnExpression : any
>preAst : any
>returnExpression : any
>walker.walk(preAst.returnExpression, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.returnExpression : any
>preAst : any
>returnExpression : any
>preAst : any
            }
        }

        export function walkForStatementChildren(preAst: ForStatement, parent: AST, walker: IAstWalker): void {
>walkForStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.init) {
>preAst.init : any
>preAst : any
>init : any

                preAst.init = walker.walk(preAst.init, preAst);
>preAst.init = walker.walk(preAst.init, preAst) : any
>preAst.init : any
>preAst : any
>init : any
>walker.walk(preAst.init, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.init : any
>preAst : any
>init : any
>preAst : any
            }

            if (preAst.cond && walker.options.goNextSibling) {
>preAst.cond && walker.options.goNextSibling : boolean
>preAst.cond : any
>preAst : any
>cond : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.cond = walker.walk(preAst.cond, preAst);
>preAst.cond = walker.walk(preAst.cond, preAst) : any
>preAst.cond : any
>preAst : any
>cond : any
>walker.walk(preAst.cond, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.cond : any
>preAst : any
>cond : any
>preAst : any
            }

            if (preAst.incr && walker.options.goNextSibling) {
>preAst.incr && walker.options.goNextSibling : boolean
>preAst.incr : any
>preAst : any
>incr : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.incr = walker.walk(preAst.incr, preAst);
>preAst.incr = walker.walk(preAst.incr, preAst) : any
>preAst.incr : any
>preAst : any
>incr : any
>walker.walk(preAst.incr, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.incr : any
>preAst : any
>incr : any
>preAst : any
            }

            if (preAst.body && walker.options.goNextSibling) {
>preAst.body && walker.options.goNextSibling : boolean
>preAst.body : any
>preAst : any
>body : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.body = walker.walk(preAst.body, preAst);
>preAst.body = walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkForInStatementChildren(preAst: ForInStatement, parent: AST, walker: IAstWalker): void {
>walkForInStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            preAst.lval = walker.walk(preAst.lval, preAst);
>preAst.lval = walker.walk(preAst.lval, preAst) : any
>preAst.lval : any
>preAst : any
>lval : any
>walker.walk(preAst.lval, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.lval : any
>preAst : any
>lval : any
>preAst : any

            if (walker.options.goNextSibling) {
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.obj = walker.walk(preAst.obj, preAst);
>preAst.obj = walker.walk(preAst.obj, preAst) : any
>preAst.obj : any
>preAst : any
>obj : any
>walker.walk(preAst.obj, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.obj : any
>preAst : any
>obj : any
>preAst : any
            }
            if (preAst.body && (walker.options.goNextSibling)) {
>preAst.body && (walker.options.goNextSibling) : boolean
>preAst.body : any
>preAst : any
>body : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.body = walker.walk(preAst.body, preAst);
>preAst.body = walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkIfStatementChildren(preAst: IfStatement, parent: AST, walker: IAstWalker): void {
>walkIfStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            preAst.cond = walker.walk(preAst.cond, preAst);
>preAst.cond = walker.walk(preAst.cond, preAst) : any
>preAst.cond : any
>preAst : any
>cond : any
>walker.walk(preAst.cond, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.cond : any
>preAst : any
>cond : any
>preAst : any

            if (preAst.thenBod && (walker.options.goNextSibling)) {
>preAst.thenBod && (walker.options.goNextSibling) : boolean
>preAst.thenBod : any
>preAst : any
>thenBod : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.thenBod = walker.walk(preAst.thenBod, preAst);
>preAst.thenBod = walker.walk(preAst.thenBod, preAst) : any
>preAst.thenBod : any
>preAst : any
>thenBod : any
>walker.walk(preAst.thenBod, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.thenBod : any
>preAst : any
>thenBod : any
>preAst : any
            }
            if (preAst.elseBod && (walker.options.goNextSibling)) {
>preAst.elseBod && (walker.options.goNextSibling) : boolean
>preAst.elseBod : any
>preAst : any
>elseBod : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.elseBod = walker.walk(preAst.elseBod, preAst);
>preAst.elseBod = walker.walk(preAst.elseBod, preAst) : any
>preAst.elseBod : any
>preAst : any
>elseBod : any
>walker.walk(preAst.elseBod, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.elseBod : any
>preAst : any
>elseBod : any
>preAst : any
            }
        }

        export function walkWhileStatementChildren(preAst: WhileStatement, parent: AST, walker: IAstWalker): void {
>walkWhileStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            preAst.cond = walker.walk(preAst.cond, preAst);
>preAst.cond = walker.walk(preAst.cond, preAst) : any
>preAst.cond : any
>preAst : any
>cond : any
>walker.walk(preAst.cond, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.cond : any
>preAst : any
>cond : any
>preAst : any

            if (preAst.body && (walker.options.goNextSibling)) {
>preAst.body && (walker.options.goNextSibling) : boolean
>preAst.body : any
>preAst : any
>body : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.body = walker.walk(preAst.body, preAst);
>preAst.body = walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkDoWhileStatementChildren(preAst: DoWhileStatement, parent: AST, walker: IAstWalker): void {
>walkDoWhileStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            preAst.cond = walker.walk(preAst.cond, preAst);
>preAst.cond = walker.walk(preAst.cond, preAst) : any
>preAst.cond : any
>preAst : any
>cond : any
>walker.walk(preAst.cond, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.cond : any
>preAst : any
>cond : any
>preAst : any

            if (preAst.body && (walker.options.goNextSibling)) {
>preAst.body && (walker.options.goNextSibling) : boolean
>preAst.body : any
>preAst : any
>body : any
>(walker.options.goNextSibling) : boolean
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.body = walker.walk(preAst.body, preAst);
>preAst.body = walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkBlockChildren(preAst: Block, parent: AST, walker: IAstWalker): void {
>walkBlockChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.statements) {
>preAst.statements : any
>preAst : any
>statements : any

                preAst.statements = <ASTList>walker.walk(preAst.statements, preAst);
>preAst.statements = <ASTList>walker.walk(preAst.statements, preAst) : any
>preAst.statements : any
>preAst : any
>statements : any
><ASTList>walker.walk(preAst.statements, preAst) : any
>walker.walk(preAst.statements, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.statements : any
>preAst : any
>statements : any
>preAst : any
            }
        }

        export function walkCaseStatementChildren(preAst: CaseStatement, parent: AST, walker: IAstWalker): void {
>walkCaseStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.expr) {
>preAst.expr : any
>preAst : any
>expr : any

                preAst.expr = walker.walk(preAst.expr, preAst);
>preAst.expr = walker.walk(preAst.expr, preAst) : any
>preAst.expr : any
>preAst : any
>expr : any
>walker.walk(preAst.expr, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.expr : any
>preAst : any
>expr : any
>preAst : any
            }

            if (preAst.body && walker.options.goNextSibling) {
>preAst.body && walker.options.goNextSibling : boolean
>preAst.body : any
>preAst : any
>body : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.body = <ASTList>walker.walk(preAst.body, preAst);
>preAst.body = <ASTList>walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
><ASTList>walker.walk(preAst.body, preAst) : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkSwitchStatementChildren(preAst: SwitchStatement, parent: AST, walker: IAstWalker): void {
>walkSwitchStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.val) {
>preAst.val : any
>preAst : any
>val : any

                preAst.val = walker.walk(preAst.val, preAst);
>preAst.val = walker.walk(preAst.val, preAst) : any
>preAst.val : any
>preAst : any
>val : any
>walker.walk(preAst.val, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.val : any
>preAst : any
>val : any
>preAst : any
            }

            if ((preAst.caseList) && walker.options.goNextSibling) {
>(preAst.caseList) && walker.options.goNextSibling : boolean
>(preAst.caseList) : any
>preAst.caseList : any
>preAst : any
>caseList : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.caseList = <ASTList>walker.walk(preAst.caseList, preAst);
>preAst.caseList = <ASTList>walker.walk(preAst.caseList, preAst) : any
>preAst.caseList : any
>preAst : any
>caseList : any
><ASTList>walker.walk(preAst.caseList, preAst) : any
>walker.walk(preAst.caseList, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.caseList : any
>preAst : any
>caseList : any
>preAst : any
            }
        }

        export function walkTryChildren(preAst: Try, parent: AST, walker: IAstWalker): void {
>walkTryChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.body) {
>preAst.body : any
>preAst : any
>body : any

                preAst.body = walker.walk(preAst.body, preAst);
>preAst.body = walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkTryCatchChildren(preAst: TryCatch, parent: AST, walker: IAstWalker): void {
>walkTryCatchChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.tryNode) {
>preAst.tryNode : any
>preAst : any
>tryNode : any

                preAst.tryNode = <Try>walker.walk(preAst.tryNode, preAst);
>preAst.tryNode = <Try>walker.walk(preAst.tryNode, preAst) : any
>preAst.tryNode : any
>preAst : any
>tryNode : any
><Try>walker.walk(preAst.tryNode, preAst) : any
>walker.walk(preAst.tryNode, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.tryNode : any
>preAst : any
>tryNode : any
>preAst : any
            }

            if ((preAst.catchNode) && walker.options.goNextSibling) {
>(preAst.catchNode) && walker.options.goNextSibling : boolean
>(preAst.catchNode) : any
>preAst.catchNode : any
>preAst : any
>catchNode : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.catchNode = <Catch>walker.walk(preAst.catchNode, preAst);
>preAst.catchNode = <Catch>walker.walk(preAst.catchNode, preAst) : any
>preAst.catchNode : any
>preAst : any
>catchNode : any
><Catch>walker.walk(preAst.catchNode, preAst) : any
>walker.walk(preAst.catchNode, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.catchNode : any
>preAst : any
>catchNode : any
>preAst : any
            }
        }

        export function walkTryFinallyChildren(preAst: TryFinally, parent: AST, walker: IAstWalker): void {
>walkTryFinallyChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.tryNode) {
>preAst.tryNode : any
>preAst : any
>tryNode : any

                preAst.tryNode = walker.walk(preAst.tryNode, preAst);
>preAst.tryNode = walker.walk(preAst.tryNode, preAst) : any
>preAst.tryNode : any
>preAst : any
>tryNode : any
>walker.walk(preAst.tryNode, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.tryNode : any
>preAst : any
>tryNode : any
>preAst : any
            }

            if (preAst.finallyNode && walker.options.goNextSibling) {
>preAst.finallyNode && walker.options.goNextSibling : boolean
>preAst.finallyNode : any
>preAst : any
>finallyNode : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.finallyNode = <Finally>walker.walk(preAst.finallyNode, preAst);
>preAst.finallyNode = <Finally>walker.walk(preAst.finallyNode, preAst) : any
>preAst.finallyNode : any
>preAst : any
>finallyNode : any
><Finally>walker.walk(preAst.finallyNode, preAst) : any
>walker.walk(preAst.finallyNode, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.finallyNode : any
>preAst : any
>finallyNode : any
>preAst : any
            }
        }

        export function walkFinallyChildren(preAst: Finally, parent: AST, walker: IAstWalker): void {
>walkFinallyChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.body) {
>preAst.body : any
>preAst : any
>body : any

                preAst.body = walker.walk(preAst.body, preAst);
>preAst.body = walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkCatchChildren(preAst: Catch, parent: AST, walker: IAstWalker): void {
>walkCatchChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.param) {
>preAst.param : any
>preAst : any
>param : any

                preAst.param = <VarDecl>walker.walk(preAst.param, preAst);
>preAst.param = <VarDecl>walker.walk(preAst.param, preAst) : any
>preAst.param : any
>preAst : any
>param : any
><VarDecl>walker.walk(preAst.param, preAst) : any
>walker.walk(preAst.param, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.param : any
>preAst : any
>param : any
>preAst : any
            }

            if ((preAst.body) && walker.options.goNextSibling) {
>(preAst.body) && walker.options.goNextSibling : boolean
>(preAst.body) : any
>preAst.body : any
>preAst : any
>body : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.body = walker.walk(preAst.body, preAst);
>preAst.body = walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkRecordChildren(preAst: NamedDeclaration, parent: AST, walker: IAstWalker): void {
>walkRecordChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            preAst.name = <Identifier>walker.walk(preAst.name, preAst);
>preAst.name = <Identifier>walker.walk(preAst.name, preAst) : any
>preAst.name : any
>preAst : any
>name : any
><Identifier>walker.walk(preAst.name, preAst) : any
>walker.walk(preAst.name, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.name : any
>preAst : any
>name : any
>preAst : any

            if (walker.options.goNextSibling && preAst.members) {
>walker.options.goNextSibling && preAst.members : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean
>preAst.members : any
>preAst : any
>members : any

                preAst.members = <ASTList>walker.walk(preAst.members, preAst);
>preAst.members = <ASTList>walker.walk(preAst.members, preAst) : any
>preAst.members : any
>preAst : any
>members : any
><ASTList>walker.walk(preAst.members, preAst) : any
>walker.walk(preAst.members, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.members : any
>preAst : any
>members : any
>preAst : any
            }

        }

        export function walkNamedTypeChildren(preAst: TypeDeclaration, parent: AST, walker: IAstWalker): void {
>walkNamedTypeChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            walkRecordChildren(preAst, parent, walker);
>walkRecordChildren(preAst, parent, walker) : void
>walkRecordChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker
        }

        export function walkClassDeclChildren(preAst: ClassDeclaration, parent: AST, walker: IAstWalker): void {
>walkClassDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            walkNamedTypeChildren(preAst, parent, walker);
>walkNamedTypeChildren(preAst, parent, walker) : void
>walkNamedTypeChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (walker.options.goNextSibling && preAst.extendsList) {
>walker.options.goNextSibling && preAst.extendsList : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean
>preAst.extendsList : any
>preAst : any
>extendsList : any

                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);
>preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst) : any
>preAst.extendsList : any
>preAst : any
>extendsList : any
><ASTList>walker.walk(preAst.extendsList, preAst) : any
>walker.walk(preAst.extendsList, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.extendsList : any
>preAst : any
>extendsList : any
>preAst : any
            }

            if (walker.options.goNextSibling && preAst.implementsList) {
>walker.options.goNextSibling && preAst.implementsList : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean
>preAst.implementsList : any
>preAst : any
>implementsList : any

                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);
>preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst) : any
>preAst.implementsList : any
>preAst : any
>implementsList : any
><ASTList>walker.walk(preAst.implementsList, preAst) : any
>walker.walk(preAst.implementsList, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.implementsList : any
>preAst : any
>implementsList : any
>preAst : any
            }
        }

        export function walkScriptChildren(preAst: Script, parent: AST, walker: IAstWalker): void {
>walkScriptChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.bod) {
>preAst.bod : any
>preAst : any
>bod : any

                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);
>preAst.bod = <ASTList>walker.walk(preAst.bod, preAst) : any
>preAst.bod : any
>preAst : any
>bod : any
><ASTList>walker.walk(preAst.bod, preAst) : any
>walker.walk(preAst.bod, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.bod : any
>preAst : any
>bod : any
>preAst : any
            }
        }

        export function walkTypeDeclChildren(preAst: InterfaceDeclaration, parent: AST, walker: IAstWalker): void {
>walkTypeDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            walkNamedTypeChildren(preAst, parent, walker);
>walkNamedTypeChildren(preAst, parent, walker) : void
>walkNamedTypeChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            // walked arguments as part of members
            if (walker.options.goNextSibling && preAst.extendsList) {
>walker.options.goNextSibling && preAst.extendsList : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean
>preAst.extendsList : any
>preAst : any
>extendsList : any

                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);
>preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst) : any
>preAst.extendsList : any
>preAst : any
>extendsList : any
><ASTList>walker.walk(preAst.extendsList, preAst) : any
>walker.walk(preAst.extendsList, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.extendsList : any
>preAst : any
>extendsList : any
>preAst : any
            }

            if (walker.options.goNextSibling && preAst.implementsList) {
>walker.options.goNextSibling && preAst.implementsList : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean
>preAst.implementsList : any
>preAst : any
>implementsList : any

                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);
>preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst) : any
>preAst.implementsList : any
>preAst : any
>implementsList : any
><ASTList>walker.walk(preAst.implementsList, preAst) : any
>walker.walk(preAst.implementsList, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.implementsList : any
>preAst : any
>implementsList : any
>preAst : any
            }
        }

        export function walkModuleDeclChildren(preAst: ModuleDeclaration, parent: AST, walker: IAstWalker): void {
>walkModuleDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            walkRecordChildren(preAst, parent, walker);
>walkRecordChildren(preAst, parent, walker) : void
>walkRecordChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker
        }

        export function walkImportDeclChildren(preAst: ImportDeclaration, parent: AST, walker: IAstWalker): void {
>walkImportDeclChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.id) {
>preAst.id : any
>preAst : any
>id : any

                preAst.id = <Identifier>walker.walk(preAst.id, preAst);
>preAst.id = <Identifier>walker.walk(preAst.id, preAst) : any
>preAst.id : any
>preAst : any
>id : any
><Identifier>walker.walk(preAst.id, preAst) : any
>walker.walk(preAst.id, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.id : any
>preAst : any
>id : any
>preAst : any
            }
            if (preAst.alias) {
>preAst.alias : any
>preAst : any
>alias : any

                preAst.alias = walker.walk(preAst.alias, preAst);
>preAst.alias = walker.walk(preAst.alias, preAst) : any
>preAst.alias : any
>preAst : any
>alias : any
>walker.walk(preAst.alias, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.alias : any
>preAst : any
>alias : any
>preAst : any
            }
        }

        export function walkWithStatementChildren(preAst: WithStatement, parent: AST, walker: IAstWalker): void {
>walkWithStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            if (preAst.expr) {
>preAst.expr : any
>preAst : any
>expr : any

                preAst.expr = walker.walk(preAst.expr, preAst);
>preAst.expr = walker.walk(preAst.expr, preAst) : any
>preAst.expr : any
>preAst : any
>expr : any
>walker.walk(preAst.expr, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.expr : any
>preAst : any
>expr : any
>preAst : any
            }

            if (preAst.body && walker.options.goNextSibling) {
>preAst.body && walker.options.goNextSibling : boolean
>preAst.body : any
>preAst : any
>body : any
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.body = walker.walk(preAst.body, preAst);
>preAst.body = walker.walk(preAst.body, preAst) : any
>preAst.body : any
>preAst : any
>body : any
>walker.walk(preAst.body, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.body : any
>preAst : any
>body : any
>preAst : any
            }
        }

        export function walkLabelChildren(preAst: Label, parent: AST, walker: IAstWalker): void {
>walkLabelChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            //TODO: Walk "id"?
        }

        export function walkLabeledStatementChildren(preAst: LabeledStatement, parent: AST, walker: IAstWalker): void {
>walkLabeledStatementChildren : (preAst: any, parent: any, walker: IAstWalker) => void
>preAst : any
>parent : any
>walker : IAstWalker

            preAst.labels = <ASTList>walker.walk(preAst.labels, preAst);
>preAst.labels = <ASTList>walker.walk(preAst.labels, preAst) : any
>preAst.labels : any
>preAst : any
>labels : any
><ASTList>walker.walk(preAst.labels, preAst) : any
>walker.walk(preAst.labels, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.labels : any
>preAst : any
>labels : any
>preAst : any

            if (walker.options.goNextSibling) {
>walker.options.goNextSibling : boolean
>walker.options : AstWalkOptions
>walker : IAstWalker
>options : AstWalkOptions
>goNextSibling : boolean

                preAst.stmt = walker.walk(preAst.stmt, preAst);
>preAst.stmt = walker.walk(preAst.stmt, preAst) : any
>preAst.stmt : any
>preAst : any
>stmt : any
>walker.walk(preAst.stmt, preAst) : any
>walker.walk : (ast: any, parent: any) => any
>walker : IAstWalker
>walk : (ast: any, parent: any) => any
>preAst.stmt : any
>preAst : any
>stmt : any
>preAst : any
            }
        }
    }
}
