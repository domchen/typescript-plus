export = example;
declare class example {
    static VERSION: string;
    static add(value: any, other: any): any;
    static after(n: any, func: any): any;
    static ary(func: any, n: any, guard: any): any;
    static assign(...args: any[]): any;
    static assignIn(...args: any[]): any;
    static assignInWith(...args: any[]): any;
    static assignWith(...args: any[]): any;
    static at(...args: any[]): any;
    static attempt(...args: any[]): any;
    static before(n: any, func: any): any;
    static bindAll(...args: any[]): any;
    static camelCase(string: any): any;
    static capitalize(string: any): any;
    static castArray(...args: any[]): any;
    static ceil(number: any, precision: any): any;
    static chain(value: any): any;
    static chunk(array: any, size: any, guard: any): any;
    static clamp(number: any, lower: any, upper: any): any;
    static clone(value: any): any;
    static cloneDeep(value: any): any;
    static cloneDeepWith(value: any, customizer: any): any;
    static cloneWith(value: any, customizer: any): any;
    static compact(array: any): any;
    static concat(...args: any[]): any;
    static cond(pairs: any): any;
    static conforms(source: any): any;
    static conformsTo(object: any, source: any): any;
    static constant(value: any): any;
    static countBy(collection: any, iteratee: any): any;
    static create(prototype: any, properties: any): any;
    static debounce(func: any, wait: any, options: any): any;
    static deburr(string: any): any;
    static defaultTo(value: any, defaultValue: any): any;
    static defaults(...args: any[]): any;
    static defaultsDeep(...args: any[]): any;
    static defer(...args: any[]): any;
    static delay(...args: any[]): any;
    static difference(...args: any[]): any;
    static differenceBy(...args: any[]): any;
    static differenceWith(...args: any[]): any;
    static divide(value: any, other: any): any;
    static drop(array: any, n: any, guard: any): any;
    static dropRight(array: any, n: any, guard: any): any;
    static dropRightWhile(array: any, predicate: any): any;
    static dropWhile(array: any, predicate: any): any;
    static each(collection: any, iteratee: any): any;
    static eachRight(collection: any, iteratee: any): any;
    static endsWith(string: any, target: any, position: any): any;
    static entries(object: any): any;
    static entriesIn(object: any): any;
    static eq(value: any, other: any): any;
    static escape(string: any): any;
    static escapeRegExp(string: any): any;
    static every(collection: any, predicate: any, guard: any): any;
    static extend(...args: any[]): any;
    static extendWith(...args: any[]): any;
    static fill(array: any, value: any, start: any, end: any): any;
    static filter(collection: any, predicate: any): any;
    static find(collection: any, predicate: any, fromIndex: any): any;
    static findIndex(array: any, predicate: any, fromIndex: any): any;
    static findKey(object: any, predicate: any): any;
    static findLast(collection: any, predicate: any, fromIndex: any): any;
    static findLastIndex(array: any, predicate: any, fromIndex: any): any;
    static findLastKey(object: any, predicate: any): any;
    static first(array: any): any;
    static flatMap(collection: any, iteratee: any): any;
    static flatMapDeep(collection: any, iteratee: any): any;
    static flatMapDepth(collection: any, iteratee: any, depth: any): any;
    static flatten(array: any): any;
    static flattenDeep(array: any): any;
    static flattenDepth(array: any, depth: any): any;
    static flip(func: any): any;
    static floor(number: any, precision: any): any;
    static flow(...args: any[]): any;
    static flowRight(...args: any[]): any;
    static forEach(collection: any, iteratee: any): any;
    static forEachRight(collection: any, iteratee: any): any;
    static forIn(object: any, iteratee: any): any;
    static forInRight(object: any, iteratee: any): any;
    static forOwn(object: any, iteratee: any): any;
    static forOwnRight(object: any, iteratee: any): any;
    static fromPairs(pairs: any): any;
    static functions(object: any): any;
    static functionsIn(object: any): any;
    static get(object: any, path: any, defaultValue: any): any;
    static groupBy(collection: any, iteratee: any): any;
    static gt(value: any, other: any): any;
    static gte(value: any, other: any): any;
    static has(object: any, path: any): any;
    static hasIn(object: any, path: any): any;
    static head(array: any): any;
    static identity(value: any): any;
    static inRange(number: any, start: any, end: any): any;
    static includes(collection: any, value: any, fromIndex: any, guard: any): any;
    static indexOf(array: any, value: any, fromIndex: any): any;
    static initial(array: any): any;
    static intersection(...args: any[]): any;
    static intersectionBy(...args: any[]): any;
    static intersectionWith(...args: any[]): any;
    static invert(object: any, iteratee: any): any;
    static invertBy(object: any, iteratee: any): any;
    static invoke(...args: any[]): any;
    static invokeMap(...args: any[]): any;
    static isArguments(value: any): any;
    static isArray(p0: any): any;
    static isArrayBuffer(value: any): any;
    static isArrayLike(value: any): any;
    static isArrayLikeObject(value: any): any;
    static isBoolean(value: any): any;
    static isBuffer(b: any): any;
    static isDate(value: any): any;
    static isElement(value: any): any;
    static isEmpty(value: any): any;
    static isEqual(value: any, other: any): any;
    static isEqualWith(value: any, other: any, customizer: any): any;
    static isError(value: any): any;
    static isFinite(value: any): any;
    static isFunction(value: any): any;
    static isInteger(value: any): any;
    static isLength(value: any): any;
    static isMap(value: any): any;
    static isMatch(object: any, source: any): any;
    static isMatchWith(object: any, source: any, customizer: any): any;
    static isNaN(value: any): any;
    static isNative(value: any): any;
    static isNil(value: any): any;
    static isNull(value: any): any;
    static isNumber(value: any): any;
    static isObject(value: any): any;
    static isObjectLike(value: any): any;
    static isPlainObject(value: any): any;
    static isRegExp(value: any): any;
    static isSafeInteger(value: any): any;
    static isSet(value: any): any;
    static isString(value: any): any;
    static isSymbol(value: any): any;
    static isTypedArray(value: any): any;
    static isUndefined(value: any): any;
    static isWeakMap(value: any): any;
    static isWeakSet(value: any): any;
    static iteratee(func: any): any;
    static join(array: any, separator: any): any;
    static kebabCase(string: any): any;
    static keyBy(collection: any, iteratee: any): any;
    static keys(object: any): any;
    static keysIn(object: any): any;
    static last(array: any): any;
    static lastIndexOf(array: any, value: any, fromIndex: any): any;
    static lowerCase(string: any): any;
    static lowerFirst(string: any): any;
    static lt(value: any, other: any): any;
    static lte(value: any, other: any): any;
    static map(collection: any, iteratee: any): any;
    static mapKeys(object: any, iteratee: any): any;
    static mapValues(object: any, iteratee: any): any;
    static matches(source: any): any;
    static matchesProperty(path: any, srcValue: any): any;
    static max(array: any): any;
    static maxBy(array: any, iteratee: any): any;
    static mean(array: any): any;
    static meanBy(array: any, iteratee: any): any;
    static merge(...args: any[]): any;
    static mergeWith(...args: any[]): any;
    static method(...args: any[]): any;
    static methodOf(...args: any[]): any;
    static min(array: any): any;
    static minBy(array: any, iteratee: any): any;
    static mixin(object: any, source: any, options: any): any;
    static multiply(value: any, other: any): any;
    static negate(predicate: any): any;
    static noConflict(): any;
    static noop(): void;
    static now(): any;
    static nth(array: any, n: any): any;
    static nthArg(n: any): any;
    static omit(...args: any[]): any;
    static omitBy(object: any, predicate: any): any;
    static once(func: any): any;
    static orderBy(collection: any, iteratees: any, orders: any, guard: any): any;
    static over(...args: any[]): any;
    static overArgs(...args: any[]): any;
    static overEvery(...args: any[]): any;
    static overSome(...args: any[]): any;
    static pad(string: any, length: any, chars: any): any;
    static padEnd(string: any, length: any, chars: any): any;
    static padStart(string: any, length: any, chars: any): any;
    static parseInt(string: any, radix: any, guard: any): any;
    static partition(collection: any, iteratee: any): any;
    static pick(...args: any[]): any;
    static pickBy(object: any, predicate: any): any;
    static property(path: any): any;
    static propertyOf(object: any): any;
    static pull(...args: any[]): any;
    static pullAll(array: any, values: any): any;
    static pullAllBy(array: any, values: any, iteratee: any): any;
    static pullAllWith(array: any, values: any, comparator: any): any;
    static pullAt(...args: any[]): any;
    static random(lower: any, upper: any, floating: any): any;
    static range(start: any, end: any, step: any): any;
    static rangeRight(start: any, end: any, step: any): any;
    static rearg(...args: any[]): any;
    static reduce(collection: any, iteratee: any, accumulator: any, ...args: any[]): any;
    static reduceRight(collection: any, iteratee: any, accumulator: any, ...args: any[]): any;
    static reject(collection: any, predicate: any): any;
    static remove(array: any, predicate: any): any;
    static repeat(string: any, n: any, guard: any): any;
    static replace(...args: any[]): any;
    static rest(func: any, start: any): any;
    static result(object: any, path: any, defaultValue: any): any;
    static reverse(array: any): any;
    static round(number: any, precision: any): any;
    static runInContext(context: any): any;
    static sample(collection: any): any;
    static sampleSize(collection: any, n: any, guard: any): any;
    static set(object: any, path: any, value: any): any;
    static setWith(object: any, path: any, value: any, customizer: any): any;
    static shuffle(collection: any): any;
    static size(collection: any): any;
    static slice(array: any, start: any, end: any): any;
    static snakeCase(string: any): any;
    static some(collection: any, predicate: any, guard: any): any;
    static sortBy(...args: any[]): any;
    static sortedIndex(array: any, value: any): any;
    static sortedIndexBy(array: any, value: any, iteratee: any): any;
    static sortedIndexOf(array: any, value: any): any;
    static sortedLastIndex(array: any, value: any): any;
    static sortedLastIndexBy(array: any, value: any, iteratee: any): any;
    static sortedLastIndexOf(array: any, value: any): any;
    static sortedUniq(array: any): any;
    static sortedUniqBy(array: any, iteratee: any): any;
    static split(string: any, separator: any, limit: any): any;
    static spread(func: any, start: any): any;
    static startCase(string: any): any;
    static startsWith(string: any, target: any, position: any): any;
    static stubArray(): any;
    static stubFalse(): any;
    static stubObject(): any;
    static stubString(): any;
    static stubTrue(): any;
    static subtract(value: any, other: any): any;
    static sum(array: any): any;
    static sumBy(array: any, iteratee: any): any;
    static tail(array: any): any;
    static take(array: any, n: any, guard: any): any;
    static takeRight(array: any, n: any, guard: any): any;
    static takeRightWhile(array: any, predicate: any): any;
    static takeWhile(array: any, predicate: any): any;
    static tap(value: any, interceptor: any): any;
    static template(string: any, options: any, guard: any): any;
    static templateSettings: {
        escape: RegExp;
        evaluate: RegExp;
        imports: {};
        interpolate: RegExp;
        variable: string;
    };
    static throttle(func: any, wait: any, options: any): any;
    static thru(value: any, interceptor: any): any;
    static times(n: any, iteratee: any): any;
    static toArray(value: any): any;
    static toFinite(value: any): any;
    static toInteger(value: any): any;
    static toLength(value: any): any;
    static toLower(value: any): any;
    static toNumber(value: any): any;
    static toPairs(object: any): any;
    static toPairsIn(object: any): any;
    static toPath(value: any): any;
    static toPlainObject(value: any): any;
    static toSafeInteger(value: any): any;
    static toString(value: any): any;
    static toUpper(value: any): any;
    static transform(object: any, iteratee: any, accumulator: any): any;
    static trim(string: any, chars: any, guard: any): any;
    static trimEnd(string: any, chars: any, guard: any): any;
    static trimStart(string: any, chars: any, guard: any): any;
    static truncate(string: any, options: any): any;
    static unary(func: any): any;
    static unescape(string: any): any;
    static union(...args: any[]): any;
    static unionBy(...args: any[]): any;
    static unionWith(...args: any[]): any;
    static uniq(array: any): any;
    static uniqBy(array: any, iteratee: any): any;
    static uniqWith(array: any, comparator: any): any;
    static uniqueId(prefix: any): any;
    static unset(object: any, path: any): any;
    static unzip(array: any): any;
    static unzipWith(array: any, iteratee: any): any;
    static update(object: any, path: any, updater: any): any;
    static updateWith(object: any, path: any, updater: any, customizer: any): any;
    static upperCase(string: any): any;
    static upperFirst(string: any): any;
    static values(object: any): any;
    static valuesIn(object: any): any;
    static without(...args: any[]): any;
    static words(string: any, pattern: any, guard: any): any;
    static wrap(value: any, wrapper: any): any;
    static xor(...args: any[]): any;
    static xorBy(...args: any[]): any;
    static xorWith(...args: any[]): any;
    static zip(...args: any[]): any;
    static zipObject(props: any, values: any): any;
    static zipObjectDeep(props: any, values: any): any;
    static zipWith(...args: any[]): any;
    constructor(value: any);
    add(...args: any[]): any;
    after(...args: any[]): any;
    ary(...args: any[]): any;
    assign(...args: any[]): any;
    assignIn(...args: any[]): any;
    assignInWith(...args: any[]): any;
    assignWith(...args: any[]): any;
    at(...args: any[]): any;
    attempt(...args: any[]): any;
    before(...args: any[]): any;
    bind(...args: any[]): any;
    bindAll(...args: any[]): any;
    bindKey(...args: any[]): any;
    camelCase(...args: any[]): any;
    capitalize(...args: any[]): any;
    castArray(...args: any[]): any;
    ceil(...args: any[]): any;
    chain(): any;
    chunk(...args: any[]): any;
    clamp(...args: any[]): any;
    clone(...args: any[]): any;
    cloneDeep(...args: any[]): any;
    cloneDeepWith(...args: any[]): any;
    cloneWith(...args: any[]): any;
    commit(): any;
    compact(...args: any[]): any;
    concat(...args: any[]): any;
    cond(...args: any[]): any;
    conforms(...args: any[]): any;
    conformsTo(...args: any[]): any;
    constant(...args: any[]): any;
    countBy(...args: any[]): any;
    create(...args: any[]): any;
    curry(...args: any[]): any;
    curryRight(...args: any[]): any;
    debounce(...args: any[]): any;
    deburr(...args: any[]): any;
    defaultTo(...args: any[]): any;
    defaults(...args: any[]): any;
    defaultsDeep(...args: any[]): any;
    defer(...args: any[]): any;
    delay(...args: any[]): any;
    difference(...args: any[]): any;
    differenceBy(...args: any[]): any;
    differenceWith(...args: any[]): any;
    divide(...args: any[]): any;
    drop(...args: any[]): any;
    dropRight(...args: any[]): any;
    dropRightWhile(...args: any[]): any;
    dropWhile(...args: any[]): any;
    each(...args: any[]): any;
    eachRight(...args: any[]): any;
    endsWith(...args: any[]): any;
    entries(...args: any[]): any;
    entriesIn(...args: any[]): any;
    eq(...args: any[]): any;
    escape(...args: any[]): any;
    escapeRegExp(...args: any[]): any;
    every(...args: any[]): any;
    extend(...args: any[]): any;
    extendWith(...args: any[]): any;
    fill(...args: any[]): any;
    filter(...args: any[]): any;
    find(...args: any[]): any;
    findIndex(...args: any[]): any;
    findKey(...args: any[]): any;
    findLast(...args: any[]): any;
    findLastIndex(...args: any[]): any;
    findLastKey(...args: any[]): any;
    first(...args: any[]): any;
    flatMap(...args: any[]): any;
    flatMapDeep(...args: any[]): any;
    flatMapDepth(...args: any[]): any;
    flatten(...args: any[]): any;
    flattenDeep(...args: any[]): any;
    flattenDepth(...args: any[]): any;
    flip(...args: any[]): any;
    floor(...args: any[]): any;
    flow(...args: any[]): any;
    flowRight(...args: any[]): any;
    forEach(...args: any[]): any;
    forEachRight(...args: any[]): any;
    forIn(...args: any[]): any;
    forInRight(...args: any[]): any;
    forOwn(...args: any[]): any;
    forOwnRight(...args: any[]): any;
    fromPairs(...args: any[]): any;
    functions(...args: any[]): any;
    functionsIn(...args: any[]): any;
    get(...args: any[]): any;
    groupBy(...args: any[]): any;
    gt(...args: any[]): any;
    gte(...args: any[]): any;
    has(...args: any[]): any;
    hasIn(...args: any[]): any;
    head(...args: any[]): any;
    identity(...args: any[]): any;
    inRange(...args: any[]): any;
    includes(...args: any[]): any;
    indexOf(...args: any[]): any;
    initial(...args: any[]): any;
    intersection(...args: any[]): any;
    intersectionBy(...args: any[]): any;
    intersectionWith(...args: any[]): any;
    invert(...args: any[]): any;
    invertBy(...args: any[]): any;
    invoke(...args: any[]): any;
    invokeMap(...args: any[]): any;
    isArguments(...args: any[]): any;
    isArray(...args: any[]): any;
    isArrayBuffer(...args: any[]): any;
    isArrayLike(...args: any[]): any;
    isArrayLikeObject(...args: any[]): any;
    isBoolean(...args: any[]): any;
    isBuffer(...args: any[]): any;
    isDate(...args: any[]): any;
    isElement(...args: any[]): any;
    isEmpty(...args: any[]): any;
    isEqual(...args: any[]): any;
    isEqualWith(...args: any[]): any;
    isError(...args: any[]): any;
    isFinite(...args: any[]): any;
    isFunction(...args: any[]): any;
    isInteger(...args: any[]): any;
    isLength(...args: any[]): any;
    isMap(...args: any[]): any;
    isMatch(...args: any[]): any;
    isMatchWith(...args: any[]): any;
    isNaN(...args: any[]): any;
    isNative(...args: any[]): any;
    isNil(...args: any[]): any;
    isNull(...args: any[]): any;
    isNumber(...args: any[]): any;
    isObject(...args: any[]): any;
    isObjectLike(...args: any[]): any;
    isPlainObject(...args: any[]): any;
    isRegExp(...args: any[]): any;
    isSafeInteger(...args: any[]): any;
    isSet(...args: any[]): any;
    isString(...args: any[]): any;
    isSymbol(...args: any[]): any;
    isTypedArray(...args: any[]): any;
    isUndefined(...args: any[]): any;
    isWeakMap(...args: any[]): any;
    isWeakSet(...args: any[]): any;
    iteratee(...args: any[]): any;
    join(...args: any[]): any;
    kebabCase(...args: any[]): any;
    keyBy(...args: any[]): any;
    keys(...args: any[]): any;
    keysIn(...args: any[]): any;
    last(...args: any[]): any;
    lastIndexOf(...args: any[]): any;
    lowerCase(...args: any[]): any;
    lowerFirst(...args: any[]): any;
    lt(...args: any[]): any;
    lte(...args: any[]): any;
    map(...args: any[]): any;
    mapKeys(...args: any[]): any;
    mapValues(...args: any[]): any;
    matches(...args: any[]): any;
    matchesProperty(...args: any[]): any;
    max(...args: any[]): any;
    maxBy(...args: any[]): any;
    mean(...args: any[]): any;
    meanBy(...args: any[]): any;
    memoize(...args: any[]): any;
    merge(...args: any[]): any;
    mergeWith(...args: any[]): any;
    method(...args: any[]): any;
    methodOf(...args: any[]): any;
    min(...args: any[]): any;
    minBy(...args: any[]): any;
    mixin(...args: any[]): any;
    multiply(...args: any[]): any;
    negate(...args: any[]): any;
    next(): any;
    noConflict(...args: any[]): any;
    noop(...args: any[]): any;
    now(...args: any[]): any;
    nth(...args: any[]): any;
    nthArg(...args: any[]): any;
    omit(...args: any[]): any;
    omitBy(...args: any[]): any;
    once(...args: any[]): any;
    orderBy(...args: any[]): any;
    over(...args: any[]): any;
    overArgs(...args: any[]): any;
    overEvery(...args: any[]): any;
    overSome(...args: any[]): any;
    pad(...args: any[]): any;
    padEnd(...args: any[]): any;
    padStart(...args: any[]): any;
    parseInt(...args: any[]): any;
    partial(...args: any[]): any;
    partialRight(...args: any[]): any;
    partition(...args: any[]): any;
    pick(...args: any[]): any;
    pickBy(...args: any[]): any;
    plant(value: any): any;
    pop(...args: any[]): any;
    property(...args: any[]): any;
    propertyOf(...args: any[]): any;
    pull(...args: any[]): any;
    pullAll(...args: any[]): any;
    pullAllBy(...args: any[]): any;
    pullAllWith(...args: any[]): any;
    pullAt(...args: any[]): any;
    push(...args: any[]): any;
    random(...args: any[]): any;
    range(...args: any[]): any;
    rangeRight(...args: any[]): any;
    rearg(...args: any[]): any;
    reduce(...args: any[]): any;
    reduceRight(...args: any[]): any;
    reject(...args: any[]): any;
    remove(...args: any[]): any;
    repeat(...args: any[]): any;
    replace(...args: any[]): any;
    rest(...args: any[]): any;
    result(...args: any[]): any;
    reverse(): any;
    round(...args: any[]): any;
    runInContext(...args: any[]): any;
    sample(...args: any[]): any;
    sampleSize(...args: any[]): any;
    set(...args: any[]): any;
    setWith(...args: any[]): any;
    shift(...args: any[]): any;
    shuffle(...args: any[]): any;
    size(...args: any[]): any;
    slice(...args: any[]): any;
    snakeCase(...args: any[]): any;
    some(...args: any[]): any;
    sort(...args: any[]): any;
    sortBy(...args: any[]): any;
    sortedIndex(...args: any[]): any;
    sortedIndexBy(...args: any[]): any;
    sortedIndexOf(...args: any[]): any;
    sortedLastIndex(...args: any[]): any;
    sortedLastIndexBy(...args: any[]): any;
    sortedLastIndexOf(...args: any[]): any;
    sortedUniq(...args: any[]): any;
    sortedUniqBy(...args: any[]): any;
    splice(...args: any[]): any;
    split(...args: any[]): any;
    spread(...args: any[]): any;
    startCase(...args: any[]): any;
    startsWith(...args: any[]): any;
    stubArray(...args: any[]): any;
    stubFalse(...args: any[]): any;
    stubObject(...args: any[]): any;
    stubString(...args: any[]): any;
    stubTrue(...args: any[]): any;
    subtract(...args: any[]): any;
    sum(...args: any[]): any;
    sumBy(...args: any[]): any;
    tail(...args: any[]): any;
    take(...args: any[]): any;
    takeRight(...args: any[]): any;
    takeRightWhile(...args: any[]): any;
    takeWhile(...args: any[]): any;
    tap(...args: any[]): any;
    template(...args: any[]): any;
    throttle(...args: any[]): any;
    thru(...args: any[]): any;
    times(...args: any[]): any;
    toArray(...args: any[]): any;
    toFinite(...args: any[]): any;
    toInteger(...args: any[]): any;
    toJSON(): any;
    toLength(...args: any[]): any;
    toLower(...args: any[]): any;
    toNumber(...args: any[]): any;
    toPairs(...args: any[]): any;
    toPairsIn(...args: any[]): any;
    toPath(...args: any[]): any;
    toPlainObject(...args: any[]): any;
    toSafeInteger(...args: any[]): any;
    toUpper(...args: any[]): any;
    transform(...args: any[]): any;
    trim(...args: any[]): any;
    trimEnd(...args: any[]): any;
    trimStart(...args: any[]): any;
    truncate(...args: any[]): any;
    unary(...args: any[]): any;
    unescape(...args: any[]): any;
    union(...args: any[]): any;
    unionBy(...args: any[]): any;
    unionWith(...args: any[]): any;
    uniq(...args: any[]): any;
    uniqBy(...args: any[]): any;
    uniqWith(...args: any[]): any;
    uniqueId(...args: any[]): any;
    unset(...args: any[]): any;
    unshift(...args: any[]): any;
    unzip(...args: any[]): any;
    unzipWith(...args: any[]): any;
    update(...args: any[]): any;
    updateWith(...args: any[]): any;
    upperCase(...args: any[]): any;
    upperFirst(...args: any[]): any;
    value(): any;
    valueOf(): any;
    values(...args: any[]): any;
    valuesIn(...args: any[]): any;
    without(...args: any[]): any;
    words(...args: any[]): any;
    wrap(...args: any[]): any;
    xor(...args: any[]): any;
    xorBy(...args: any[]): any;
    xorWith(...args: any[]): any;
    zip(...args: any[]): any;
    zipObject(...args: any[]): any;
    zipObjectDeep(...args: any[]): any;
    zipWith(...args: any[]): any;
}
declare namespace example {
    function bind(...args: any[]): any;
    namespace bind {
        // Circular reference from example.bind
        const placeholder: any;
    }
    function bindKey(...args: any[]): any;
    namespace bindKey {
        // Circular reference from example.bindKey
        const placeholder: any;
    }
    function curry(func: any, arity: any, guard: any): any;
    namespace curry {
        // Circular reference from example.curry
        const placeholder: any;
    }
    function curryRight(func: any, arity: any, guard: any): any;
    namespace curryRight {
        // Circular reference from example.curryRight
        const placeholder: any;
    }
    function memoize(func: any, resolver: any): any;
    namespace memoize {
        class Cache {
            constructor(entries: any);
            clear(): void;
            get(key: any): any;
            has(key: any): any;
            set(key: any, value: any): any;
        }
    }
    function partial(...args: any[]): any;
    namespace partial {
        // Circular reference from example.partial
        const placeholder: any;
    }
    function partialRight(...args: any[]): any;
    namespace partialRight {
        // Circular reference from example.partialRight
        const placeholder: any;
    }
}